import argparse
import os 
os.environ['TOKENIZERS_PARALLELISM'] = 'false'

from datetime import datetime
import torch
import torch.nn as nn
from torch.utils.tensorboard import SummaryWriter
from tqdm import tqdm
from torch.nn import functional as nnf
from torch.utils.data import DataLoader
from model.model_with_prompt import PromptModel, PromptModelWithConnection
from datasets import ImageCaptionDataset, prepare_data
from utils import CosineSchedule, generate, calculate_metrics, save_config, save_info, save_config_and_metric

def train(args, train_dataset, valid_dataset, model):
    print(args)
    batch_size = args.bs
    device = args.device
    epochs = args.epochs
    model = model.to(device)
    
    model.train()
    if args.optimizer_type == 'Adam':
        optimizer = torch.optim.Adam(model.parameters(), lr=args.lr, betas=args.betas)
    elif args.optimizer_type == 'AdamW':
        optimizer = torch.optim.AdamW(model.parameters(), lr=args.lr, betas=args.betas)
    else:
        raise NotImplementedError

    train_dataloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True, drop_last=True, num_workers=args.num_workers)
    valid_dataloader = DataLoader(valid_dataset, batch_size=batch_size, shuffle=True, drop_last=False, num_workers=args.num_workers)

    scheduler = CosineSchedule(optimizer, K=args.scheduler_k)
    writer = SummaryWriter(args.out_dir)

    # TRAINING + VALIDATION LOOP
    best_epoch = -1
    highest_avg = -1
    best_metrics = None
    for epoch in range(epochs):
        for param_group in optimizer.param_groups:
            lr = param_group["lr"]
            print(f'>>> Training epoch {epoch} - LR: {lr}')
        progress = tqdm(total=len(train_dataloader))
        total_train_loss = 0

        # Training loop
        for idx, (img_path, img_tensor, hard_text_prompt, caption) in enumerate(train_dataloader):
            """
            - img_path: tuple, len = batch_size
            - img_tensors: tensor, shape (bs, c, w, h)
            - caption: tuple, len = batch_size
            """
            model.zero_grad()
            # prepare inputs
            img_tensor = img_tensor.to(device, dtype=torch.float32)

            # get query for prompt and calculate a similarity loss
            q = model.get_query(img_tensor)
            n_K = nn.functional.normalize(model.key, dim=1)
            q = nn.functional.normalize(q, dim=1).detach()
            cos_sim = torch.einsum('bj,kj->bk', q, n_K)
            loss_1 = 1.0 - sum(cos_sim)/batch_size
            
            # forward
            outputs = model(img_tensor, caption)

            # get result
            output_logits = outputs['last_layer_logits'] # bs, seq_len, vocab_size
            token_ids = outputs['input_ids']             # generated by tokenizer, used as a target in the loss
            
            # causal model => shift input and logits
            hard_prompt_len = model.tokenizer(hard_text_prompt[0], return_tensors="pt").input_ids.shape[1] - 1 
            shift_logits = output_logits[..., hard_prompt_len-1:-1, :].contiguous()   # skip the last token and hard-prompt tokens
            shift_labels = token_ids[..., hard_prompt_len:].contiguous()            # skip the first token_id (bos) and hard-prompt

            # shift_logits = output_logits[..., :-1, :].contiguous()   # skip the last token_embed
            # shift_labels = token_ids[..., 1:].contiguous()           # skip the first token_id (bos)

            # calculate loss
            loss_2 = nnf.cross_entropy(shift_logits.view(-1, shift_logits.size(-1)), shift_labels.view(-1))
            loss = loss_1 + loss_2
            total_train_loss += loss_1.item() + loss_2.item()

            # backprop
            loss.backward()
            optimizer.step()
            optimizer.zero_grad()
            progress.set_postfix({"loss": loss.item()})
            progress.update()
        scheduler.step()
        progress.close()

        torch.save({
            'epoch': epoch,
            'model_state_dict': model.state_dict(),
            'optimizer_state_dict': optimizer.state_dict(),
            'schedulerr_state_dict': scheduler.state_dict(),
            'loss': loss,
            }, 
            os.path.join(args.out_dir, f"{args.prefix_outdir}-{epoch}.pt"),
        )

        ground_truth_list = []
        prediction_list = []

        # Validation loop
        if epoch % args.valid_every == 0:
            print(f">>> Evaluating epoch {epoch}")
            progress = tqdm(total=len(valid_dataloader))
            with torch.no_grad():
                for _, (img_path, img_tensor, hard_text_prompt, caption) in enumerate(valid_dataloader):
                    img_tensor = img_tensor.to(device, dtype=torch.float32)  # bs x 3 x 512 x 512                    
                    gen_cap = generate(model, img_tensor, hard_text_prompt, args)
                    ground_truth_list += caption
                    prediction_list += gen_cap
                    progress.update()
            progress.close()
        
        assert len(ground_truth_list) == len(prediction_list)
        # Log info to writer
        log_info = {}
        log_info['val_metrics'] = calculate_metrics(args.dataset, ground_truth_list, prediction_list)
        log_info['lr'] = lr
        log_info['train_loss'] = total_train_loss/len(train_dataset)
        log_info['ground_truth_list'] = ground_truth_list
        log_info['prediction_list'] = prediction_list
        save_info(args, log_info, writer, epoch)
        if log_info['val_metrics']['valid_avg'] > highest_avg:
            highest_avg = log_info['val_metrics']['valid_avg']
            best_epoch = epoch
            best_metrics = log_info['val_metrics']
    
    print(args)
    print('FINISHED !!!!')
    print(f'Best epoch: {best_epoch}')
    print(best_metrics)
    save_config_and_metric(args, best_metrics, best_epoch)

    return model


def main():
    now = datetime.now()

    parser = argparse.ArgumentParser()

    # Dataset
    parser.add_argument('--dataset', choices=['colon-1', 'prostate-1', 'gastric'],default='colon-1')

    # Training configuaration
    parser.add_argument('--epochs', type=int, default=3)
    parser.add_argument('--bs', type=int, default=256)
    parser.add_argument('--device', type=int, default=2)
    parser.add_argument('--optimizer_type', type=str, default="Adam")
    parser.add_argument('--lr', type=float, default=1e-3)
    parser.add_argument('--betas', type=tuple, default=(0.9, 0.999))
    parser.add_argument('--valid_every', type=int, default=1)
    parser.add_argument('--num_workers', type=int, default=20)
    parser.add_argument('--scheduler_k', type=int, default=100)
    parser.add_argument('--generate_length', type=int, default=6)

    # Encoder
    parser.add_argument('--encoder_type', type=str, default='ctranspath')
    parser.add_argument('--encoder_prompt_len', type=int, default=40)
    parser.add_argument('--encoder_ckpt_path', type=str, default='/home/compu/anhnguyen/prompt_works/model/ctranspath.pth')
    parser.add_argument('--encoder_skip_layers', type=list, default=[6,7,8,9,10,11])
    parser.add_argument('--encoder_resize', default=224)
    parser.add_argument('--encoder_mean', default=(0.485, 0.456, 0.406))
    parser.add_argument('--encoder_std', default=(0.229, 0.224, 0.225))

    # Projector
    parser.add_argument('--layers_dim', type=list, default=[768, 1024, 4096, 2048, 512])
    parser.add_argument('--proj_activation', type=str, default='gelu')
    
    # Decoder
    parser.add_argument('--decoder_type', type=str, default='d_plip')
    parser.add_argument('--visual_feature_position', type=str, choices=['in_key_and_value', 'in_input'],default='in_key_and_value')
    parser.add_argument('--decoder_prompt_len', type=int, default=40)
    parser.add_argument('--decoder_ckpt_path', type=str, default='/home/compu/anhnguyen/prompt_works/model/plip_ckpt')
    parser.add_argument('--decoder_skip_layers', type=list, default=[6,7,8,9,10,11]) # skip for prompt
    parser.add_argument('--decoder_skip_layers_for_visual', type=list, default=[])   # skip for visual feature
    parser.add_argument('--tokenizer_type', type=str, default="vinid/plip")

    # Saving configuration
    parser.add_argument('--out_dir', default='/data4/anhnguyen/experiments/prompt_work/')
    parser.add_argument('--prefix_outdir', type=str, default="test")

    args = parser.parse_args()

    log_skip_layers_encoder = str(args.encoder_skip_layers)[1:-1].replace(', ', '') if args.encoder_skip_layers != [] else 'full'
    log_skip_layers_decoder = str(args.decoder_skip_layers)[1:-1].replace(', ', '') if args.decoder_skip_layers != [] else 'full'
    log_skip_layers_decoder_visual = str(args.decoder_skip_layers_for_visual)[1:-1].replace(', ', '') if args.decoder_skip_layers_for_visual != [] else 'full'

    args.scheduler_k = args.epochs
    
    args.prefix_outdir = '-'.join((args.dataset, 
                                    args.encoder_type,
                                    str(args.encoder_prompt_len),
                                    log_skip_layers_encoder,
                                    f"project_{args.layers_dim[-1]}",
                                    args.decoder_type,
                                    str(args.decoder_prompt_len),
                                    log_skip_layers_decoder,
                                    log_skip_layers_decoder_visual,
                                    args.prefix_outdir,
                                    str(now)[-3:]
                                    ))

    args.out_dir = args.out_dir + args.prefix_outdir 

    if "test" not in args.prefix_outdir:
        if not os.path.exists(args.out_dir):
            os.makedirs(args.out_dir)
        
        save_config(args)
    else:
        print('=>>>>> TESTING')

    args.device = torch.device(f'cuda:{args.device}')
    
    data = prepare_data(args.dataset)
    if isinstance(data,tuple):
        train_set, valid_set = data[0], data[1]
    else:
        raise ValueError('Not contains a splitted training data')
    
    model = PromptModel(args)
    train_dataset = ImageCaptionDataset(train_set, args)
    valid_dataset = ImageCaptionDataset(valid_set, args, train=False)

    train(args, train_dataset, valid_dataset, model)

if __name__ == '__main__':
    main()